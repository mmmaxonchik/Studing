# Транспортный уровень
Задачами транспортного уровня являются:
+ Передача данных между процессами на хостах
+ Адресация
+ Предоставление нужного уровня надежности передачи данных, не зависимо от надежности сети 

> Транспортный уровень позволяет скрыть от разработчиков приложений детали нижних уровней

**Адресация:**
На транспортном уро вне адресами называют порты - число от 1 до 65535, каждое сетевое приложение имеет свой порт. Номера портов у приложений не повторяются.
_Форма записи:_ IP-адрес:Порт 

**Типы портов:**
+ 1-1024 - Хорошо известные порты (Примеры: HTTP-80, SMTP-25, 53-DNS...) - запускать могут только пользователи с правами администратора
+ 1025 - 49151 - Зарезервированные порты
+ 49151-65535 - Динамические порты - автоматически выдаются клиенту

**Надежность транспортного уровня:**
+ Гарантия доставки - подтверждение получения, повторная отправка не подтвержденных данных
+ Гарантия порядка следования сообщений - имеется нумерация сообщений

**Протоколы:**
+ TCP - обеспечивает надежность доставки
+ UDP - не гарантирует доставки данных, но работает быстрее чем TCP

**Интерфейсом транспортного уровня** - является сокет

## UDP
UDP(User Datagram Protocol) - протокол дейтаграмм пользователя, сообщение UDP называется дейтаграмма, аналогия с телеграммой.

**Особенности UDP:**
+ Нет соединения
+ Нет гарантий доставки 
+ Нет гарантии сохранения порядка сообщений
> В случае использования протокола UDP - надежность доставки не повышается по сравнению с IP

**Формат пакета UDP:**
+ Заголовок
+ + Порт отправителя(2 байта)
+ + Порт получателя(2 байта)
+ + Длина UDP(2 байта) - длинна всей датаграммы
+ + Контрольная сумма(2 байта)
+ Данные

**Преимуществом UDP в сравнении с TCP является скорость работы**, так как нет расходов на установку соединения.

## TCP
TCP(Transmission Control Protocol) - протокол управления передачей. TCP обладает надежной передачей потока байт, также TCP предоставляет гарантии доставки данных и сохранения порядка следования сообщения. 

Транспортный уровень получает поток байт от приложения, поток разбивается на отдельные части - _сегменты_. Сегменты передаются _отдельно_ от отправителя к получателю. Получатель собирает сегменты и передает принимающему приложению поток байт.

**Гарантия доставки:**
+ Отправитель посылает сегмент данных и устанавливает таймер
+ Получатель принимает сегмент данных и посылает подтверждение(ACK), в случае если сегмент не был получен, то по истечению таймера отправитель снова посылает сегмент 

> На самом деле в протоколе TCP подтверждается не каждый сегмент, а несколько сегментов отправленных друг за другом, данный механизм называется _скользящее окно_.

Для того чтобы сегменты приходили по порядку и не дублировались существует ***нумерация байтов***, при отправлении данных отправитель добавляет порядок байт, а получатель принимает сегмент и отправляет байт на котором закончился сегмент.

> Перед отправкой данных по TCP необходимо установить соединение, это делается для того чтобы убедиться что отправитель и получатель хотят передавать данные друг-другу, договориться о нумерации потока байт, договориться о параметрах соединения. После завершения передачи данных соединение разрывается.

### Скользящее окно
В протоколе TCP используется гарантия доставки данных, для этого используется подтверждение. Варианты подтверждения:
+ Остановка и ожидание (Wi-Fi, канальный уровень) - в таком случае получатель должен при каждой передаче сегмента отправлять подтверждение о его получении
+ Скользящее окно (TCP, транспортный уровень) -  в таком случае данные отправляются сразу несколькими порциями не дожидаясь подтверждения, а в конце отправляет кумулятивное подтверждение.

### Соединение
Порядок соединения:
1. Отправитель посылает сообщение SYN(Synchronization), с нумерацией байт
2. Получатель принимает сообщение и посылает ответ SYN, следующую нумерацию байт и ACK нумерации байт которых уже принял
3. После этого соединение считается установленным 

TCP соединение дуплексное - данные могут передаваться в обе стороны, при таком подходе есть два варианта разрыва соединения:
+ Одновременное
+ Одностороннее

Существует два способа разрыва соединения - отправкой сообщения FIN, при таком подходе получатель отправляет в ответ ACK, и далее также отправляет сообщение FIN и получает на него ACK. Второй способ это отправка сообщения RST, при таком подходе соединение закрывается в обе стороны.

### Формат заголовка(32 бита)
+ Порт отправителя
+ Порт получателя
+ Порядковый номер -  первый номер байтов в сегменте. нАпример при использовании Ethernet сегмент будет составлять 1460 байт, так-как 20 - заголовок TCP, 20 - заголовок IP, 1460 - сегмент
+ Номер подтверждения - кумулятивное подтверждение, означает что все предыдущие байты получены
+ Длина заголовка - так как есть необязательные поля необходима длина заголовка
+ Флаги:
+ + N S
+ + C W R
+ + E C B
+ + U R G - в сегменте содержатся срочные данные которое необходимо передать приложению
+ + A C K - подтверждение принятой ранее информации
+ + P S H - промежуточные данные необходимо передать в срочном порядке приложению, без записи в буфер
+ + R S T - разрыв соединения
+ + S Y N - установление соединения
+ + F I N - разрыв соединения
+ Размер окна - получатель указывает сколько данных может принять
+ Контрольная сумма 
+ Указатель на срочные данные
+ Параметры(Не обязательно)
+ + MSS - максимальный размер сегмента
+ + Масштаб окна - позволяет увеличить размер окна до 1ГБ
+ + SACK - выборочное подтверждение, подтверждение диапазонов принятых байт
+ + Метки времени
+ Данные(Не обязательно)

### Управление потоком в TCP
В сети могут быть устройства разной производительности, поэтому чтобы не было "затопления" медленного получателя используют управление потоком.

> Затопление также может возникнуть из за заполненности буфера, сервер будет отправлять новые сегменты, приложение не будет их читать, буфер будет заполнен и новые сегменты не будут записываться. 

Для того чтобы понять сколько байт данных может принять получатель есть специальное поле _размер окна_. 

> Если отправитель долго ждет он может отправить Zero Window Probe, чтобы убедиться что размер окна все еще равен 0.

### Управление перегрузкой в TCP
На момент отправки сегментов отправителем сеть может быть перегружена и сегменты могут не дойти до получателя, для того чтобы исправить эту проблему придумали механизм _окно перегрузки_.

Данный механизм решает задачу скорости передачи в TCP, размеры окон могут быть маленькие и большие для того чтобы найти оптимальный размер окна есть метод AIMD - метод Аддитивного увелечения, мультипликативное уменьшение.

## Интерфейс сокетов
Сокеты - стандарт интерфейсов для транспортного уровня.

Операции сокетов делятся на четыре части:
+ Создание сокетов
+ + Socket - создать новый сокет
+ + Bind - создать сокет с IP-адресом и портом
+ + Listen - объявить желание принимать соединение
+ Установка соединения
+ + Accept - Принять запрос на установку соединения
+ + Connect - Установить соединение
+ Передача данных
+ + Send - отправить данные по сети
+ + Receive - Получить данные из сети
+ Закрытие соединения 
+ + Close - Закрыть соединение

> Сокеты используют модель клиент сервер. Сервер - прослушивает IP-адрес и порт и пассивно ждет запросов, клиент - активно устанавливает соединение с сервером на заданном порту.

**Работа сокетов:**
+ Сервер
1. Создание сокета - Socket
2. Привязка сокета к IP-адресу и порту - Bind
3. Объявление желания принятия соединения - Listen
4. Принятие соединения - Accept
5. Создание копии сокета
6. Получение данных из сети - Receive
+ Клиент
1. Создание сокета - Socket
2. Установка соединения - Connect
3. Отправка данных по сети - Send
4. Закрытие соединения - Close

**Типы сокетов:**
+ Протоколы сетевого уровня - IPv4, IPv6
+ Протоколы транспортного уровня - TCP, UDP
+ Есть другие но используются редко...

